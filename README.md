# MemGraph

A developer tool that analyzes memory access patterns using graphlet (small subgraph) analysis. MemGraph helps developers understand their program's memory behavior beyond simple cache miss rates.

## Features

- **Multiple Trace Format Support**: Parse traces from Valgrind Lackey, CSV, and MemGraph's native format
- **Synthetic Trace Generation**: Generate test traces with various access patterns
- **CLI Interface**: Easy-to-use command-line interface with rich terminal output
- **Streaming Parsing**: Handle large trace files efficiently
- **Type-Safe**: Fully typed Python code

## Installation

### Development Installation

Clone the repository and install in development mode:

```bash
git clone <repository-url>
cd memgraph
pip install -e ".[dev]"
```

This installs MemGraph in editable mode with all development dependencies (pytest, mypy, etc.).

### Regular Installation

```bash
pip install .
```

## Usage

### Parsing Trace Files

Parse a trace file and display summary statistics:

```bash
# Auto-detect format
memgraph parse trace.log

# Specify format explicitly
memgraph parse trace.log --format=lackey
memgraph parse trace.csv --format=csv
memgraph parse trace.native --format=native
```

Example output:

```
╭─────────────────── Trace Summary ───────────────────╮
│ Source: trace.log                                   │
│ Format: lackey                                      │
│ Total accesses: 1,234,567                          │
│ Unique addresses: 45,678                           │
│ Reads: 890,123 (72.1%)                             │
│ Writes: 344,444 (27.9%)                            │
│ Address range: 0x7fff5a8b0000 - 0x7fff5a8c0000    │
╰────────────────────────────────────────────────────╯
```

### Generating Synthetic Traces

Generate synthetic traces for testing:

```bash
# Sequential pattern
memgraph generate sequential --size=10000 -o trace.native

# Random access pattern
memgraph generate random --size=10000 -o trace.native

# Strided pattern (e.g., array column traversal)
memgraph generate strided --size=10000 --stride=64 -o trace.native

# Pointer chase (linked list traversal)
memgraph generate pointer_chase --size=10000 -o trace.native

# Working set pattern (temporal locality)
memgraph generate working_set --size=10000 -o trace.native
```

### Listing Supported Formats

```bash
memgraph formats
```

### Listing Available Patterns

```bash
memgraph patterns
```

## Trace Formats

### Valgrind Lackey Format

Generated by Valgrind with the Lackey tool:

```
I  04000000,3
 S 7ff000398,8
 L 7ff000398,8
 M 7ff000390,8
```

- `I` = instruction fetch (ignored)
- `S` = store (write)
- `L` = load (read)
- `M` = modify (read + write)

Format: `<type> <address>,<size>`

### CSV Format

Simple comma-separated values:

```csv
op,address,size
R,0x7fff5a8b1000,8
W,0x7fff5a8b1008,4
```

### Native Format

MemGraph's native format with explicit timestamps:

```
# MemGraph Trace v1
R,0x7fff5a8b1000,8,0
W,0x7fff5a8b1008,4,1
```

Format: `operation,address,size,timestamp`

## Development

### Running Tests

```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=memgraph --cov-report=term-missing

# Run specific test file
pytest tests/test_parser.py
```

### Type Checking

```bash
mypy src/memgraph
```

### Project Structure

```
memgraph/
├── pyproject.toml          # Project configuration
├── README.md               # This file
├── src/
│   └── memgraph/
│       ├── __init__.py
│       ├── cli.py          # Command-line interface
│       ├── trace/
│       │   ├── models.py   # Data models
│       │   ├── parser.py   # Main parsing logic
│       │   ├── generator.py # Synthetic trace generation
│       │   └── formats/
│       │       ├── base.py     # Abstract parser
│       │       ├── lackey.py   # Valgrind Lackey parser
│       │       ├── csv.py      # CSV parser
│       │       └── native.py   # Native format parser
│       └── utils/
│           └── logging.py
└── tests/
    ├── conftest.py         # Pytest fixtures
    ├── test_parser.py      # Parser tests
    └── test_generator.py   # Generator tests
```

## Synthetic Trace Patterns

### Sequential

Linear sequential access pattern simulating array traversal:

```python
from memgraph.trace.generator import generate_sequential

trace = generate_sequential(n=1000, start_addr=0x1000, stride=8)
```

### Random

Uniform random access pattern:

```python
from memgraph.trace.generator import generate_random

trace = generate_random(n=1000, addr_range=(0x1000, 0x10000), seed=42)
```

### Strided

Strided access pattern (e.g., column-major array access):

```python
from memgraph.trace.generator import generate_strided

trace = generate_strided(n=1000, stride=64, count=100)
```

### Pointer Chase

Simulated linked list traversal:

```python
from memgraph.trace.generator import generate_pointer_chase

trace = generate_pointer_chase(n=1000, num_nodes=100, seed=42)
```

### Working Set

Dense reuse within a working set (temporal locality):

```python
from memgraph.trace.generator import generate_working_set

trace = generate_working_set(
    n=1000,
    working_set_size=50,
    total_addresses=1000,
    hot_probability=0.8,
    seed=42
)
```

## API Usage

### Parsing Traces Programmatically

```python
from pathlib import Path
from memgraph.trace.parser import parse_trace

# Auto-detect format
trace = parse_trace("trace.log")

# Specify format
trace = parse_trace("trace.log", format="lackey")

# Access trace data
print(f"Total accesses: {trace.metadata.total_accesses}")
print(f"Unique addresses: {trace.metadata.unique_addresses}")

for access in trace:
    print(f"{access.operation} {hex(access.address)} ({access.size} bytes)")
```

### Lazy Parsing (Streaming)

For large traces, use lazy parsing:

```python
from memgraph.trace.formats.lackey import LackeyParser

parser = LackeyParser()
for access in parser.parse_iter("large_trace.log"):
    # Process one access at a time without loading entire trace
    process(access)
```

## Requirements

- Python 3.10 or higher
- Dependencies:
  - typer >= 0.9.0
  - rich >= 13.0.0

- Development dependencies:
  - pytest >= 7.4.0
  - pytest-cov >= 4.1.0
  - mypy >= 1.5.0

## License

MIT

## Roadmap

This is Phase 1 of MemGraph. Future phases will include:

- **Phase 2**: Graph construction from memory traces
- **Phase 3**: Graphlet enumeration and analysis
- **Phase 4**: Pattern classification using ML
- **Phase 5**: HTML report generation
- **Phase 6**: Integration with Valgrind/PIN

## Contributing

Contributions are welcome! Please ensure:

1. All tests pass: `pytest`
2. Code is typed: `mypy src/memgraph`
3. Coverage remains high: `pytest --cov=memgraph`
